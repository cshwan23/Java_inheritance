# Java_inheritance
상속.



# 1. 상속

클래스가 소유한 멤버 속성변수, 메소드 등으 다른 [클래스]에게 그댈 물려주는 것을 말한다.
상속해준 클래스를 슈퍼클래스, 상속 받은 클래스를 [서브클래스]라고 한다.
Java API 에 정의된 모든 클래스는 기본적으로 Object 클래스로부터 상속되어 파생된 클래스들이다.
개발자가 만든 클래스가 어떤 클래스도 상속 않도록 정의했더라도 컴파일 시 자바는 내부적을 Object 클래스를 상속하도록 코드를 추가한다.


# 2. 상속 관계 설정 형식

<슈퍼 클래스 형식>

[public] [abstract] class 슈퍼클래스명 { ~ }

부모 앞에 final이 없어야 한다.

<서브 클래스 형식> 

[public] [abstract/final] class 서브클래스명 extends 슈퍼클래스명 { ~ }

<조심> 슈퍼클래스명 앞에 final 노노 상속 불가능이므로


# 3. 상속 장점

[서브 클래스]는 [슈퍼 클래스]의 멤버를 공유하므로 재사용성, 간결성, 프로그램 개발속도의 증가시킨다.
상속을 이용하면 반복되는 코드를 줄일 수 있고 클래스간의 관계를 명백히 할 수 있다.
계속 이어지는 상속으로 클래스는 계층적인 구조로 되어 전체 클래스를 보다 효율적으로 관리하고 사용할 수 있다.


# 4. 상속 특징

[슈퍼클래스]는 1개 이상의 [서브클래스]를 가질 수 있다.

- 자식 입장에서 부모를 여러명 상속받을 수 없다.
- 1명의 엄마는 여러 자식을 낳을 수 있다.

[서브클래스]를 객체화 하면 자동으로 슈퍼 클래스도 객체화 된다.
[서브클래스]의 [생성자] 안의 첫 줄에는 반드 [슈퍼클래스]의 생성자를 호출하는 super( ~ )가 있어야 한다.
super( ~ )가 없다면 JVM이 컴파일 시 super( )를 삽입한다.
결국 [서브클래스]가 객체화되면 [슈퍼클래스]의 [속성변수] 또는 [메소드]를 호출할 수 있다. 예외로 private이 붙으면 호출이 불가능하다.
[서브클래스] 객체화 후 속성변수/메소드를 호출하면 먼저 [서브클래스]엣 찾고 난 후 없으면 [슈퍼클래스]쪽에서 찾아 호출한다.
단, [슈퍼클래스]의 호출 "멤버"에 private 가 붙어 있으면 호출할 수 없다. 
[슈퍼클래스]영역에서 [슈퍼클래스]의 [메소드]를 재정의(overriding)할 수 있다.
단 final이 붙은 메소드는 불가능하고 오버라이딩 규칙에 맞게 재정의(overriding)해야한다.


# 5. 오버라이딩 (Overriding)


[슈퍼클래스]가 소유한 [메소드]를 [서브클래스]에서 같은 메소드 이름으로 [재정의]하는 것을 말한다.

(1) 오버라이딩 (Overriding)을 하는 이유

-[슈퍼클래스]의 [메소드]를 [서브클래스]가 그대로 사용하기에 맞지 않아서 원하는 형태로 수정해 사용하기 위함이다.
같은 메소드명으로 다른 기능의 메소드를 2개 이상 선언하여 사용함으로 다형성을 가진다.

(2) 메소드 오버라이딩 규칙

오버라이딩 할 [슈퍼클래스]의 [메소드]에 private 또는 final 또는 static 이 없어야 한다.

[리턴형], [메소드명], [매개 변수 개수], [매개 변수 자료형]이 모두 같아야 한다.(실행구문만 바꿀 수 있다.)

[서브클래스]의 접근지정자 범위는 {슈퍼클래스}의 접근 지정자 범위보다 같거나 커야한다.

    ~ class 슈퍼클래스명 {
        ~
        접근지정자1  성격지정자 리턴형 메소드명(~){~}
        ~
    }
 
.

    ~ class 서브클래스명 extends 슈퍼클래스명 {
        ~
        @Override
        접근지정자2  성격지정자 리턴형 메소드명(~){~}
        ~
    }

[서브클래스]의 접근지정자 범위는 {슈퍼클래스}의 접근 지정자 범위보다 같거나 커야한다
